name: Build and Release macOS App

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write

jobs:
  build:
    runs-on: macos-latest

    env:
      APP_NAME: "Video Thing"
      APP_IDENTIFIER: "com.yourdomain.videothing"
      APP_VERSION: "1.0.0"
      SCRIPT_NAME: "app.py"

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install PyQt6 setuptools

    - name: Prepare APP_DIR
      run: |
        echo "APP_DIR=./dist/${APP_NAME}.app" >> $GITHUB_ENV

    - name: Prepare CONTENTS_DIR
      run: |
        echo "CONTENTS_DIR=$APP_DIR/Contents" >> $GITHUB_ENV

    - name: Prepare MACOS_DIR
      run: |
        echo "MACOS_DIR=$CONTENTS_DIR/MacOS" >> $GITHUB_ENV

    - name: Assemble app bundle
      run: |
        # Clean previous builds
        echo "Cleaning previous builds..."
        rm -rf "$APP_DIR"
        mkdir -p "$(dirname "$APP_DIR")"
        cp -R template "$APP_DIR"

        # Create app directory structure
        echo "Creating app bundle structure..."
        mkdir -p "$MACOS_DIR" "$CONTENTS_DIR/Frameworks"

        # Copy app resources
        echo "Copying application resources..."
        cp "$SCRIPT_NAME" "$CONTENTS_DIR/Resources/"

    - name: Create main launcher
      run: |
        cat > "$MACOS_DIR/$APP_NAME" << 'EOF'
        #!/bin/bash

        # Get absolute path to the executable directory
        SELF_PATH=$(cd -P -- "$(dirname -- "$0")" && pwd -P) && SELF_PATH=$SELF_PATH/$(basename -- "$0")
        DIR=$(dirname "$SELF_PATH")

        # Get absolute path to Resources
        RESOURCES_DIR="$DIR/../Resources"
        if [ -d "$RESOURCES_DIR" ]; then
            RESOURCES_DIR=$(cd "$RESOURCES_DIR" 2>/dev/null && pwd)
        else
            # Try a fallback approach
            RESOURCES_DIR="$(dirname "$DIR")/Resources"
            if [ -d "$RESOURCES_DIR" ]; then
                RESOURCES_DIR=$(cd "$RESOURCES_DIR" 2>/dev/null && pwd)
            else
                echo "ERROR: Resources directory not found"
                exit 1
            fi
        fi

        # Download ffmpeg if not present (for current architecture)
        if [ ! -f "$RESOURCES_DIR/ffmpeg" ]; then
          echo "Downloading ffmpeg..."
          curl -JL -o "$RESOURCES_DIR/ffmpeg.zip" https://evermeet.cx/ffmpeg/getrelease/zip
          unzip "$RESOURCES_DIR/ffmpeg.zip" -d "$RESOURCES_DIR"
          rm "$RESOURCES_DIR/ffmpeg.zip"
          chmod +x "$RESOURCES_DIR/ffmpeg"
        fi

        # Download ffprobe if not present (for current architecture)
        if [ ! -f "$RESOURCES_DIR/ffprobe" ]; then
          echo "Downloading ffprobe..."
          curl -JL -o "/tmp/ffprobe.zip" https://evermeet.cx/ffmpeg/getrelease/ffprobe/zip
          unzip "/tmp/ffprobe.zip" -d "$RESOURCES_DIR"
          rm "/tmp/ffprobe.zip"
          chmod +x "$RESOURCES_DIR/ffprobe"
        fi

        # Run the app

        # Check if this is the first run
        FIRST_RUN_FLAG="$DIR/.installed"
        if [ ! -f "$FIRST_RUN_FLAG" ]; then
            # Create a temporary Python virtual environment for the right architecture
            TEMP_ENV_DIR="$DIR/venv"

            # Remove any existing environment
            if [ -d "$TEMP_ENV_DIR" ]; then
                rm -rf "$TEMP_ENV_DIR"
            fi

            # Create a fresh environment
            python3 -m venv "$TEMP_ENV_DIR"

            "$TEMP_ENV_DIR/bin/pip" install --upgrade pip

            # Install required packages
            "$TEMP_ENV_DIR/bin/pip" install PyQt6 setuptools

            # Create flag file to indicate we've run the setup
            touch "$FIRST_RUN_FLAG"
        fi

        # Use the virtual environment if it exists
        if [ -d "$DIR/venv" ]; then
            PYTHON_EXE="$DIR/venv/bin/python3"
        else
            PYTHON_EXE="python3"
        fi

        # Now run the actual app
        cd "$DIR"
        "$PYTHON_EXE" "$RESOURCES_DIR/app.py"
        EOF

        chmod +x "$MACOS_DIR/$APP_NAME"

    - name: Create Info.plist
      run: |
        echo "Creating Info.plist..."
        cat > "$CONTENTS_DIR/Info.plist" << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleDevelopmentRegion</key>
            <string>English</string>
            <key>CFBundleDisplayName</key>
            <string>$APP_NAME</string>
            <key>CFBundleExecutable</key>
            <string>$APP_NAME</string>
            <key>CFBundleIconFile</key>
            <string>icon.icns</string>
            <key>CFBundleIdentifier</key>
            <string>$APP_IDENTIFIER</string>
            <key>CFBundleInfoDictionaryVersion</key>
            <string>6.0</string>
            <key>CFBundleName</key>
            <string>$APP_NAME</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleShortVersionString</key>
            <string>$APP_VERSION</string>
            <key>CFBundleVersion</key>
            <string>$APP_VERSION</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>LSApplicationCategoryType</key>
            <string>public.app-category.utilities</string>
            <key>LSMinimumSystemVersion</key>
            <string>10.14</string>
            <key>NSHumanReadableCopyright</key>
            <string>Copyright Â© 2025 $APP_NAME</string>
            <key>LSUIElement</key>
            <false/>
        </dict>
        </plist>
        EOF

    - name: Ad-hoc Code Sign App
      run: |
        codesign --force --deep --sign - "$APP_DIR"

    - name: Create DMG file
      run: |
        hdiutil create -volname "$APP_NAME" -srcfolder "$APP_DIR" -ov -format UDZO "dist/$APP_NAME.dmg"

    - name: Get version from file or set default
      id: get_version
      run: |
        if [ -f "version.txt" ]; then
          VERSION=$(cat version.txt)
        else
          VERSION=1
        fi

        # get latest tag, could also be empty
        tag=$(git tag --sort=v:refname | grep "v$VERSION\." | tail -n 1)

        # if there are none, start tags at INITIAL_VERSION which defaults to 0.0.0
        if [ -z "$tag" ]; then
          tag="v$VERSION.0.0"
        else
          array=($(echo "$tag" | tr . '\n'))
          array[2]=$((array[2]+1))
          tag=$(IFS=.; echo "${array[*]}")
        fi

        # export env var for subsequent steps
        echo "VERSION=$tag" >> $GITHUB_OUTPUT

    - name: Create release
      id: create_release
      uses: softprops/action-gh-release@v1
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      with:
        tag_name: ${{ steps.get_version.outputs.VERSION }}
        name: Release ${{ steps.get_version.outputs.VERSION }}
        draft: false
        prerelease: false
        files: |
          dist/Video Thing.dmg
        token: ${{ secrets.GITHUB_TOKEN }}
